# FP-ASM API Reference (Autogenerated)

> Extracted from Doxygen-style comments in `include/fp_core.h`.

This document is generated automatically and grouped according to the
ordering found in the public header. Each section lists the relevant
C prototypes immediately followed by the descriptive comments from the
source code.

## fp_map_axpy_f64 / fp_map_axpy_i64

```c
void fp_map_axpy_f64(const double* x, const double* y, double* out, size_t n, double c);
void fp_map_axpy_i64(const int64_t* x, const int64_t* y, int64_t* out, size_t n, int64_t c);
```

FP: out = zipWith (+) (map (*c) x) y  (Classic AXPY)
C:  for(i) { out[i] = c * x[i] + y[i]; }
Win: SIMD (FMA) for f64, Scalar unroll for i64.

## fp_map_scale_i64 / fp_map_scale_f64

```c
void fp_map_scale_i64(const int64_t* in, int64_t* out, size_t n, int64_t c);
void fp_map_scale_f64(const double* in, double* out, size_t n, double c);
```

FP: out = map (*c) in
C:  for(i) { out[i] = c * in[i]; }
Win: Scalar unroll (i64), Guaranteed SIMD (f64)

## fp_map_offset_i64 / fp_map_offset_f64

```c
void fp_map_offset_i64(const int64_t* in, int64_t* out, size_t n, int64_t c);
void fp_map_offset_f64(const double* in, double* out, size_t n, double c);
```

FP: out = map (+c) in
C:  for(i) { out[i] = in[i] + c; }
Win: Guaranteed SIMD.

## fp_zip_add_i64 / fp_zip_add_f64

```c
void fp_zip_add_i64(const int64_t* a, const int64_t* b, int64_t* out, size_t n);
void fp_zip_add_f64(const double* a, const double* b, double* out, size_t n);
```

FP: out = zipWith (+) a b
C:  for(i) { out[i] = a[i] + b[i]; }
Win: Guaranteed SIMD.

## fp_map_abs_i64 / fp_map_abs_f64

```c
void fp_map_abs_i64(const int64_t* in, int64_t* out, size_t n);
void fp_map_abs_f64(const double* in, double* out, size_t n);
```

FP: out = map abs in
C:  for(i) { out[i] = abs(in[i]); }
Win: Guaranteed SIMD using bitwise trick (i64) or mask (f64)

## fp_map_sqrt_f64

```c
void fp_map_sqrt_f64(const double* in, double* out, size_t n);
```

FP: out = map sqrt in
C:  for(i) { out[i] = sqrt(in[i]); }
Win: Guaranteed SIMD using vsqrtpd/vsqrtps

## fp_map_clamp_i64 / fp_map_clamp_f64

```c
void fp_map_clamp_i64(const int64_t* in, int64_t* out, size_t n, int64_t min_val, int64_t max_val);
void fp_map_clamp_f64(const double* in, double* out, size_t n, double min_val, double max_val);
```

FP: out = map (clamp min_val max_val) in
C:  for(i) { out[i] = max(min_val, min(max_val, in[i])); }
Win: Guaranteed SIMD (f64), Scalar for i64 (no vpmaxsq in AVX2)

## fp_scan_add_i64 / fp_scan_add_f64

```c
void fp_scan_add_i64(const int64_t* in, int64_t* out, size_t n);
void fp_scan_add_f64(const double* in, double* out, size_t n);
```

FP: out = scanl1 (+) in  (inclusive prefix sum)
C:  acc = 0; for(i) { acc += in[i]; out[i] = acc; }
Example: [1, 2, 3, 4] -> [1, 3, 6, 10]
Win: Scalar with 4-way loop unrolling

## fp_pred_all_eq_const_i64

```c
bool fp_pred_all_eq_const_i64(const int64_t* arr, size_t n, int64_t value);
```

FP: all (== value) arr
C:  for(i) if (arr[i] != value) return false; return true;
Returns true if ALL elements equal the constant value

## fp_pred_any_gt_const_i64

```c
bool fp_pred_any_gt_const_i64(const int64_t* arr, size_t n, int64_t value);
```

FP: any (> value) arr
C:  for(i) if (arr[i] > value) return true; return false;
Returns true if ANY element is greater than the constant value

## fp_pred_all_gt_zip_i64

```c
bool fp_pred_all_gt_zip_i64(const int64_t* a, const int64_t* b, size_t n);
```

FP: all (uncurry (>)) (zip a b)
C:  for(i) if (a[i] <= b[i]) return false; return true;
Returns true if ALL corresponding elements satisfy a[i] > b[i]

## fp_filter_gt_i64_simple

```c
size_t fp_filter_gt_i64_simple(const int64_t* input, int64_t* output, size_t n, int64_t threshold);
```

FP: filter (> threshold) list
C:  result = []; for(i) if (arr[i] > threshold) result.append(arr[i]);
Returns: number of elements written to output

This is the CRITICAL test for "List FP" fitness!

## fp_partition_gt_i64

```c
void fp_partition_gt_i64(const int64_t* input, int64_t* output_pass, int64_t* output_fail, size_t n, int64_t threshold, size_t* out_pass_count, size_t* out_fail_count);
```

FP: partition (> threshold) list → (pass, fail)
C:  pass = []; fail = []; for(i) { if (arr[i] > thresh) pass.append(arr[i]); else fail.append(arr[i]); }

Splits input into two outputs based on predicate.

## fp_take_while_gt_i64

```c
size_t fp_take_while_gt_i64(const int64_t* input, int64_t* output, size_t n, int64_t threshold);
```

FP: takeWhile (> threshold) list
C:  result = []; for(i) { if (arr[i] > threshold) result.append(arr[i]); else break; }

Takes elements while predicate is true, stops at first failure (early exit).

## fp_drop_while_gt_i64

```c
size_t fp_drop_while_gt_i64(const int64_t* input, int64_t* output, size_t n, int64_t threshold);
```

FP: dropWhile (> threshold) list
C:  skip = true; for(i) { if (skip && arr[i] > threshold) continue; skip = false; result.append(arr[i]); }

Drops elements while predicate is true, returns rest (early exit).

## fp_take_n_i64

```c
size_t fp_take_n_i64(const int64_t* input, int64_t* output, size_t array_len, size_t take_count);
```

FP: take n list
C:  for(i = 0; i < min(n, len); i++) output[i] = input[i];
Haskell: take 3 [1,2,3,4,5] → [1,2,3]
Returns: number of elements taken

## fp_drop_n_i64

```c
size_t fp_drop_n_i64(const int64_t* input, int64_t* output, size_t array_len, size_t drop_count);
```

FP: drop n list
C:  for(i = n; i < len; i++) output[i-n] = input[i];
Haskell: drop 2 [1,2,3,4,5] → [3,4,5]
Returns: number of elements in output

## fp_slice_i64

```c
size_t fp_slice_i64(const int64_t* input, int64_t* output, size_t array_len, size_t start, size_t end);
```

FP: take (end - start) . drop start
C:  for(i = start; i < end; i++) output[i-start] = input[i];
Haskell: slice 2 5 [0,1,2,3,4,5,6] → [2,3,4]
Returns: number of elements in output

## fp_reduce_product_i64 / fp_reduce_product_f64

```c
int64_t fp_reduce_product_i64(const int64_t* input, size_t n);
double fp_reduce_product_f64(const double* input, size_t n);
```

FP: product list
C:  result = 1; for(i) result *= arr[i];
Haskell: product [1,2,3,4] → 24
Returns: product of all elements (1 for empty array)

## fp_find_index_i64

```c
int64_t fp_find_index_i64(const int64_t* input, size_t n, int64_t target);
```

FP: findIndex (== target) list
C:  for(i) if (arr[i] == target) return i; return -1;
Haskell: findIndex (== 7) [1,3,7,2] → Just 2
Returns: index of first match, or -1 if not found

## fp_contains_i64

```c
bool fp_contains_i64(const int64_t* input, size_t n, int64_t target);
```

FP: elem target list
C:  for(i) if (arr[i] == target) return true; return false;
Haskell: elem 7 [1,3,7,2] → True
Returns: 1 if found, 0 if not found

## fp_reverse_i64

```c
void fp_reverse_i64(const int64_t* input, int64_t* output, size_t n);
```

FP: reverse list
C:  for(i) output[i] = input[n-1-i];
Haskell: reverse [1,2,3,4] → [4,3,2,1]

## fp_concat_i64

```c
size_t fp_concat_i64(const int64_t* input_a, const int64_t* input_b, int64_t* output, size_t len_a, size_t len_b);
```

FP: list1 ++ list2
C:  memcpy(output, a, na*8); memcpy(output+na, b, nb*8);
Haskell: [1,2,3] ++ [4,5,6] → [1,2,3,4,5,6]
Returns: total length (len_a + len_b)

## fp_replicate_i64

```c
void fp_replicate_i64(int64_t* output, size_t n, int64_t value);
```

FP: replicate n value
C:  for(i = 0; i < n; i++) output[i] = value;
Haskell: replicate 5 7 → [7,7,7,7,7]

## fp_sort_i64 / fp_sort_f64

```c
void fp_sort_i64(int64_t* array, size_t n);
void fp_sort_f64(double* array, size_t n);
```

FP: sort list
C:  qsort(array, n, sizeof(int64_t), cmp);
Haskell: sort [3,1,4,1,5,9] → [1,1,3,4,5,9]

Implementation: Quicksort with median-of-3 pivot + insertion sort for small arrays
Note: Sorts in-place (modifies input array)

## fp_unique_i64

```c
size_t fp_unique_i64(const int64_t* input, int64_t* output, size_t n);
```

FP: nub list  (remove consecutive duplicates)
C:  unique_copy(sorted_array, output);
Haskell: nub [1,2,2,3,3,3,4] → [1,2,3,4]

Note: Input should be sorted for correctness
Returns: number of unique elements

## fp_union_i64

```c
size_t fp_union_i64(const int64_t* array_a, const int64_t* array_b, int64_t* output, size_t len_a, size_t len_b);
```

FP: union list1 list2
C:  set_union(sorted_a, sorted_b, output);
Haskell: union [1,2,3] [2,3,4] → [1,2,3,4]

Note: Both inputs should be sorted
Returns: number of elements in union

## fp_intersect_i64

```c
size_t fp_intersect_i64(const int64_t* array_a, const int64_t* array_b, int64_t* output, size_t len_a, size_t len_b);
```

FP: intersect list1 list2
C:  set_intersection(sorted_a, sorted_b, output);
Haskell: intersect [1,2,3] [2,3,4] → [2,3]

Note: Both inputs should be sorted
Returns: number of elements in intersection

## fp_group_i64

```c
size_t fp_group_i64(const int64_t* input, int64_t* groups_out, int64_t* counts_out, size_t n);
```

FP: group list  (group consecutive equal elements)
Haskell: group [1,1,2,2,2,3] → [[1,1],[2,2,2],[3]]

Due to C constraints, returns parallel arrays:
- groups_out: representative value for each group
- counts_out: size of each group

Returns: number of groups

## fp_run_length_encode_i64

```c
size_t fp_run_length_encode_i64(const int64_t* input, int64_t* output, size_t n);
```

FP: Run-length encoding
Alternative: returns interleaved [val1, count1, val2, count2, ...]

More memory-efficient than separate arrays
Returns: number of output elements (groups * 2)

## fp_iterate_add_i64

```c
void fp_iterate_add_i64(int64_t* output, size_t n, int64_t start, int64_t step);
```

FP: iterate (+step) start
Haskell: take n $ iterate (+step) start → [start, start+step, start+2*step, ...]

Generates arithmetic sequence

## fp_iterate_mul_i64

```c
void fp_iterate_mul_i64(int64_t* output, size_t n, int64_t start, int64_t factor);
```

FP: iterate (*factor) start
Haskell: take n $ iterate (*factor) start → [start, start*factor, start*factor^2, ...]

Generates geometric sequence

## fp_range_i64

```c
size_t fp_range_i64(int64_t* output, int64_t start, int64_t end);
```

FP: [start..end-1]
Haskell: [1..10] → [1,2,3,4,5,6,7,8,9,10]

Generates range of integers
Returns: number of elements (max(0, end - start))

## fp_reduce_and_bool

```c
bool fp_reduce_and_bool(const int64_t* input, size_t n);
```

FP: and list
Haskell: and [True, True, False] → False

Returns: 1 if all elements are non-zero, 0 if any zero
Note: Treats int64_t as bool (0=false, non-zero=true)

## fp_reduce_or_bool

```c
bool fp_reduce_or_bool(const int64_t* input, size_t n);
```

FP: or list
Haskell: or [False, False, True] → True

Returns: 1 if any element is non-zero, 0 if all zero

## fp_zip_with_index_i64

```c
size_t fp_zip_with_index_i64(const int64_t* input, int64_t* output, size_t n);
```

FP: zip [0..] list
Haskell: zip [0..] list → [(0,x), (1,y), (2,z), ...]

Returns interleaved: [0, x, 1, y, 2, z, ...]
Returns: output length (n * 2)

## fp_replicate_f64

```c
void fp_replicate_f64(double* output, size_t n, double value);
```

FP: replicate n value  (floating-point version)
Haskell: replicate 5 3.14 → [3.14, 3.14, 3.14, 3.14, 3.14]

## fp_count_i64

```c
size_t fp_count_i64(const int64_t* input, size_t n, int64_t target);
```

FP: length . filter (== x)
Haskell: count (== 5) [1,5,2,5,3] → 2

Count occurrences of specific value

## typedef struct { double mean;       // First moment (average) double variance;   // Second central moment double std_dev;    // Square root of variance double skewness;   // Third standardized moment (asymmetry) double kurtosis;   // Fourth standardized moment (tail heaviness) } DescriptiveStats;

```c
typedef struct { double mean;       // First moment (average) double variance;   // Second central moment double std_dev;    // Square root of variance double skewness;   // Third standardized moment (asymmetry) double kurtosis;   // Fourth standardized moment (tail heaviness) } DescriptiveStats;
```

Descriptive Statistics Structure
Contains: mean, variance, std_dev, skewness, kurtosis

## fp_descriptive_stats_f64

```c
void fp_descriptive_stats_f64(const double* data, size_t n, DescriptiveStats* stats);
```

Calculate descriptive statistics in single pass

FP: Uses fused fold to compute all moments simultaneously
Haskell-style: foldl (\acc x -> updateMoments acc x) initialAcc data

@param data Input array of doubles
@param n Number of elements
@param stats Output structure with all statistics

Complexity: O(n) time, O(1) space
Performance: 1.5-2.0x vs naive C (single pass, fused operations)

## fp_moments_f64

```c
void fp_moments_f64(const double* data, size_t n, double* moments);
```

Calculate raw statistical moments (internal function)

@param data Input array
@param n Number of elements
@param moments Output: [sum, sum_sq, sum_cube, sum_quad]

## Quartiles

```c
typedef struct { double q1;       // 25th percentile double median;   // 50th percentile (Q2) double q3;       // 75th percentile double iqr;      // Interquartile range (Q3 - Q1) } Quartiles;
```

Quartiles structure
Contains Q1, median (Q2), Q3, and IQR

## fp_percentile_f64

```c
double fp_percentile_f64(const double* sorted_data, size_t n, double p);
```

Calculate a single percentile from sorted data

IMPORTANT: Data must be sorted in ascending order!

@param sorted_data Input array (MUST BE SORTED)
@param n Number of elements
@param p Percentile (0.0 to 1.0, e.g., 0.5 for median, 0.95 for 95th percentile)
@return Percentile value using linear interpolation

Complexity: O(1) time (assumes data is already sorted)
Performance: 1.0x vs C (simple indexing + interpolation)

## fp_percentiles_f64

```c
void fp_percentiles_f64(const double* sorted_data, size_t n, const double* p_values, size_t n_percentiles, double* results);
```

Calculate multiple percentiles at once (batch operation)

More efficient than calling fp_percentile_f64 repeatedly
IMPORTANT: Data must be sorted in ascending order!

@param sorted_data Input array (MUST BE SORTED)
@param n Number of elements
@param p_values Array of percentiles to calculate (each 0.0 to 1.0)
@param n_percentiles Number of percentiles to calculate
@param results Output array (must have space for n_percentiles values)

Complexity: O(k) where k = n_percentiles
Performance: 1.0x vs C (cache-friendly batch processing)

## fp_quartiles_f64 / Quartiles

```c
void fp_quartiles_f64(const double* sorted_data, size_t n, Quartiles* quartiles);
```

Calculate quartiles (Q1, median, Q3) and IQR in one call

IMPORTANT: Data must be sorted in ascending order!
Commonly used for box plots and outlier detection

@param sorted_data Input array (MUST BE SORTED)
@param n Number of elements
@param quartiles Output structure

Complexity: O(1) time (assumes data is already sorted)
Performance: 1.0x vs C

## fp_covariance_f64

```c
double fp_covariance_f64(const double* x, const double* y, size_t n);
```

Calculate covariance between two arrays

Covariance measures how two variables change together
Cov(X,Y) = E[(X - E[X])(Y - E[Y])] = E[XY] - E[X]E[Y]

Uses single-pass fused algorithm for efficiency

@param x First array
@param y Second array
@param n Number of elements (must be same for both arrays)
@return Covariance value

Complexity: O(n) time, O(1) space
Performance: 2.0-2.5x vs naive C (fused operations, single pass)

## fp_correlation_f64

```c
double fp_correlation_f64(const double* x, const double* y, size_t n);
```

Calculate Pearson correlation coefficient

Correlation measures linear relationship strength between two variables
Returns value in range [-1.0, 1.0]:
  -1.0 = perfect negative correlation
   0.0 = no linear correlation
  +1.0 = perfect positive correlation

Formula: r = Cov(X,Y) / (StdDev(X) * StdDev(Y))
Uses single-pass fused algorithm for maximum efficiency

@param x First array
@param y Second array
@param n Number of elements
@return Correlation coefficient (-1.0 to 1.0, or NaN if undefined)

Complexity: O(n) time, O(1) space
Performance: 2.0-2.5x vs naive C (single pass, fused operations)

## LinearRegression

```c
typedef struct { double slope;           /**< Slope (m) of the regression line */ double intercept;       /**< Y-intercept (b) of the regression line */ double r_squared;       /**< Coefficient of determination (0.0 to 1.0) */ double std_error;       /**< Standard error of estimate */ } LinearRegression;
```

Linear regression model: y = mx + b
Contains fitted coefficients and quality metrics

## fp_linear_regression_f64 / LinearRegression

```c
void fp_linear_regression_f64(const double* x, const double* y, size_t n, LinearRegression* result);
```

Compute linear regression: y = mx + b

Fits a line to the data using least squares method
Computes slope, intercept, R², and standard error

Formulas:
  slope = Cov(X,Y) / Var(X)
  intercept = mean(Y) - slope * mean(X)
  R² = (correlation)² (proportion of variance explained)
  std_error = sqrt(Σ(y_i - y_pred_i)² / (n-2))

Uses two-pass algorithm:
  Pass 1: Compute statistics for slope/intercept/R² (single-pass SIMD)
  Pass 2: Compute residuals for standard error

@param x Independent variable (predictor)
@param y Dependent variable (response)
@param n Number of data points (must be >= 2)
@param result Output struct for regression model

Edge cases:
  - n < 2: All fields set to NaN
  - n == 2: Perfect fit (R²=1.0, std_error=0.0)
  - Zero variance in x: All fields set to NaN

Complexity: O(n) time, O(1) space
Performance: 2.0-2.5x vs naive C (SIMD first pass, scalar second pass)

## fp_predict_f64 / LinearRegression

```c
double fp_predict_f64(double x_value, const LinearRegression* model);
```

Make prediction using linear regression model

Given x value, computes y = slope * x + intercept

@param x_value Input value for prediction
@param model Previously fitted regression model
@return Predicted y value

Complexity: O(1) time, O(1) space
Performance: Same as C (simple arithmetic, no optimization needed)

## fp_detect_outliers_zscore_f64

```c
size_t fp_detect_outliers_zscore_f64(const double* data, size_t n, double threshold, uint8_t* is_outlier);
```

Detect outliers using Z-score method

The Z-score measures how many standard deviations a point is from the mean:
  z = (x - mean) / stddev

A point is marked as an outlier if |z| > threshold (typically 3.0)

Uses two-pass algorithm:
  Pass 1: Compute mean and standard deviation (SIMD)
  Pass 2: Calculate Z-scores and mark outliers (scalar)

@param data Input array (unsorted)
@param n Number of elements
@param threshold Z-score threshold (typically 2.0-3.0)
@param is_outlier Output array (1=outlier, 0=normal), must be size n
@return Number of outliers detected

Edge cases:
  - n < 2: No outliers detected
  - All values identical (stddev=0): No outliers

Complexity: O(n) time, O(1) space (excluding output)
Performance: 2.0-2.5x vs naive C (SIMD first pass)

## fp_detect_outliers_iqr_f64

```c
size_t fp_detect_outliers_iqr_f64(const double* sorted_data, size_t n, double k_factor, uint8_t* is_outlier);
```

Detect outliers using IQR (Interquartile Range) method

The IQR method is robust to extreme values:
  IQR = Q3 - Q1
  lower_bound = Q1 - k * IQR
  upper_bound = Q3 + k * IQR

A point is an outlier if x < lower_bound or x > upper_bound
where k is typically 1.5 (outlier) or 3.0 (extreme outlier)

IMPORTANT: This function requires SORTED data!

@param sorted_data Input array (MUST be sorted!)
@param n Number of elements
@param k_factor IQR multiplier (typically 1.5)
@param is_outlier Output array (1=outlier, 0=normal), must be size n
@return Number of outliers detected

Edge cases:
  - n < 4: No outliers detected (insufficient data for quartiles)

Complexity: O(n) time, O(1) space (excluding output)
Performance: 1.5-2.0x vs naive C (uses percentile calculation)
