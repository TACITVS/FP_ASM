<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FP-ASM API Reference (Autogenerated) - FP-ASM Library</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f5f5f5;
        }

        .container {
            display: flex;
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            min-height: 100vh;
        }

        /* Sidebar Navigation */
        .sidebar {
            width: 280px;
            background: #2c3e50;
            color: white;
            padding: 20px;
            position: sticky;
            top: 0;
            height: 100vh;
            overflow-y: auto;
        }

        .sidebar h2 {
            color: #3498db;
            margin-bottom: 20px;
            font-size: 1.4em;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }

        .sidebar nav ul {
            list-style: none;
        }

        .sidebar nav li {
            margin: 8px 0;
        }

        .sidebar nav a {
            color: #ecf0f1;
            text-decoration: none;
            display: block;
            padding: 8px 12px;
            border-radius: 4px;
            transition: all 0.3s;
        }

        .sidebar nav a:hover {
            background: #34495e;
            color: #3498db;
            transform: translateX(5px);
        }

        .sidebar nav a.active {
            background: #3498db;
            color: white;
        }

        .sidebar .badge {
            display: inline-block;
            background: #27ae60;
            color: white;
            font-size: 0.7em;
            padding: 2px 6px;
            border-radius: 3px;
            margin-left: 8px;
        }

        /* Main Content */
        .content {
            flex: 1;
            padding: 40px 60px;
            overflow-y: auto;
        }

        .content h1 {
            color: #2c3e50;
            font-size: 2.5em;
            margin-bottom: 20px;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }

        .content h2 {
            color: #34495e;
            font-size: 2em;
            margin-top: 40px;
            margin-bottom: 15px;
            border-left: 4px solid #3498db;
            padding-left: 15px;
        }

        .content h3 {
            color: #34495e;
            font-size: 1.5em;
            margin-top: 30px;
            margin-bottom: 10px;
        }

        .content h4 {
            color: #7f8c8d;
            font-size: 1.2em;
            margin-top: 20px;
            margin-bottom: 10px;
        }

        .content p {
            margin: 15px 0;
            line-height: 1.8;
        }

        .content ul, .content ol {
            margin: 15px 0 15px 30px;
        }

        .content li {
            margin: 8px 0;
        }

        /* Code Blocks */
        .content pre {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 6px;
            overflow-x: auto;
            margin: 20px 0;
            border-left: 4px solid #3498db;
        }

        .content code {
            background: #ecf0f1;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            color: #c7254e;
        }

        .content pre code {
            background: transparent;
            padding: 0;
            color: #ecf0f1;
        }

        /* Tables */
        .content table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .content th {
            background: #3498db;
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: bold;
        }

        .content td {
            padding: 12px;
            border-bottom: 1px solid #ecf0f1;
        }

        .content tr:hover {
            background: #f8f9fa;
        }

        /* Badges */
        .badge-green {
            background: #27ae60;
            color: white;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 0.85em;
            font-weight: bold;
        }

        .badge-blue {
            background: #3498db;
            color: white;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 0.85em;
            font-weight: bold;
        }

        .badge-orange {
            background: #e67e22;
            color: white;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 0.85em;
            font-weight: bold;
        }

        /* Blockquotes */
        .content blockquote {
            border-left: 4px solid #3498db;
            padding: 15px 20px;
            background: #ecf0f1;
            margin: 20px 0;
            font-style: italic;
        }

        /* Links */
        .content a {
            color: #3498db;
            text-decoration: none;
            border-bottom: 1px solid transparent;
            transition: border-color 0.3s;
        }

        .content a:hover {
            border-bottom-color: #3498db;
        }

        /* Horizontal Rules */
        .content hr {
            border: none;
            border-top: 2px solid #ecf0f1;
            margin: 40px 0;
        }

        /* Emoji support */
        .emoji {
            font-size: 1.2em;
        }

        /* Top banner */
        .banner {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px 60px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .banner h1 {
            color: white;
            border: none;
            margin: 0;
            font-size: 1.8em;
        }

        .banner p {
            margin: 5px 0 0 0;
            opacity: 0.9;
        }

        /* Function signature boxes */
        .signature {
            background: #f8f9fa;
            border: 2px solid #3498db;
            border-radius: 6px;
            padding: 15px;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
        }

        /* Performance badges */
        .perf-badge {
            display: inline-block;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85em;
            font-weight: bold;
            margin: 5px 5px 5px 0;
        }

        .perf-excellent { background: #27ae60; color: white; }
        .perf-good { background: #2ecc71; color: white; }
        .perf-okay { background: #f39c12; color: white; }
        .perf-competitive { background: #3498db; color: white; }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 10px;
        }

        ::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        ::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }

            .sidebar {
                width: 100%;
                height: auto;
                position: relative;
            }

            .content {
                padding: 20px;
            }

            .banner {
                padding: 15px 20px;
            }
        }
    </style>
</head>
<body>
    <div class="banner">
        <h1>üöÄ FP-ASM Library Documentation</h1>
        <p>Complete Functional Programming Toolkit for C ‚Ä¢ 100% FP Coverage ‚Ä¢ 36 Functions ‚Ä¢ Production Ready</p>
    </div>
    <div class="container">
        <aside class="sidebar">
            <h2>üìö Documentation</h2>
            <nav>
                <ul>
                    <li><a href="index.html" class="">üè† Home</a></li>
                    <li><a href="README.html" class="">üìñ Overview</a></li>
                    <li><a href="QUICK_START.html" class="">üöÄ Quick Start</a></li>
                    <li><a href="EXAMPLES.html" class="">üß™ Practical Examples</a></li>
                    <li><a href="API_REFERENCE.html" class="">üìò API Reference <span class="badge">36 funcs</span></a></li>
                    <li><a href="AUTO_API_REFERENCE.html" class="active">üßµ Header Reference</a></li>
                    <li><a href="COMPLETE_LIBRARY_REPORT.html" class="">üéâ Journey Report</a></li>
                    <li><a href="TIER1_COMPLETENESS_REPORT.html" class="">üìä TIER 1 Report</a></li>
                    <li><a href="TIER2_COMPLETENESS_REPORT.html" class="">üìä TIER 2 Report</a></li>
                    <li><a href="TIER3_COMPLETENESS_REPORT.html" class="">üìä TIER 3 Report</a></li>
                    <li><a href="ACHIEVEMENT_SUMMARY.html" class="">üèÜ Achievement</a></li>
                </ul>
            </nav>
        </aside>
        <main class="content">
            <h1>FP-ASM API Reference (Autogenerated)</h1>

> Extracted from Doxygen-style comments in <code>include/fp_core.h</code>.

This document is generated automatically and grouped according to the
ordering found in the public header. Each section lists the relevant
C prototypes immediately followed by the descriptive comments from the
source code.

<h2>fp_map_axpy_f64 / fp_map_axpy_i64</h2>

<pre><code>void fp_map_axpy_f64(const double<em> x, const double</em> y, double* out, size_t n, double c);
void fp_map_axpy_i64(const int64_t<em> x, const int64_t</em> y, int64_t* out, size_t n, int64_t c);
</code></pre>

FP: out = zipWith (+) (map (*c) x) y  (Classic AXPY)
C:  for(i) { out[i] = c * x[i] + y[i]; }
Win: SIMD (FMA) for f64, Scalar unroll for i64.

<h2>fp_map_scale_i64 / fp_map_scale_f64</h2>

<pre><code>void fp_map_scale_i64(const int64_t<em> in, int64_t</em> out, size_t n, int64_t c);
void fp_map_scale_f64(const double<em> in, double</em> out, size_t n, double c);
</code></pre>

FP: out = map (*c) in
C:  for(i) { out[i] = c * in[i]; }
Win: Scalar unroll (i64), Guaranteed SIMD (f64)

<h2>fp_map_offset_i64 / fp_map_offset_f64</h2>

<pre><code>void fp_map_offset_i64(const int64_t<em> in, int64_t</em> out, size_t n, int64_t c);
void fp_map_offset_f64(const double<em> in, double</em> out, size_t n, double c);
</code></pre>

FP: out = map (+c) in
C:  for(i) { out[i] = in[i] + c; }
Win: Guaranteed SIMD.

<h2>fp_zip_add_i64 / fp_zip_add_f64</h2>

<pre><code>void fp_zip_add_i64(const int64_t<em> a, const int64_t</em> b, int64_t* out, size_t n);
void fp_zip_add_f64(const double<em> a, const double</em> b, double* out, size_t n);
</code></pre>

FP: out = zipWith (+) a b
C:  for(i) { out[i] = a[i] + b[i]; }
Win: Guaranteed SIMD.

<h2>fp_map_abs_i64 / fp_map_abs_f64</h2>

<pre><code>void fp_map_abs_i64(const int64_t<em> in, int64_t</em> out, size_t n);
void fp_map_abs_f64(const double<em> in, double</em> out, size_t n);
</code></pre>

FP: out = map abs in
C:  for(i) { out[i] = abs(in[i]); }
Win: Guaranteed SIMD using bitwise trick (i64) or mask (f64)

<h2>fp_map_sqrt_f64</h2>

<pre><code>void fp_map_sqrt_f64(const double<em> in, double</em> out, size_t n);
</code></pre>

FP: out = map sqrt in
C:  for(i) { out[i] = sqrt(in[i]); }
Win: Guaranteed SIMD using vsqrtpd/vsqrtps

<h2>fp_map_clamp_i64 / fp_map_clamp_f64</h2>

<pre><code>void fp_map_clamp_i64(const int64_t<em> in, int64_t</em> out, size_t n, int64_t min_val, int64_t max_val);
void fp_map_clamp_f64(const double<em> in, double</em> out, size_t n, double min_val, double max_val);
</code></pre>

FP: out = map (clamp min_val max_val) in
C:  for(i) { out[i] = max(min_val, min(max_val, in[i])); }
Win: Guaranteed SIMD (f64), Scalar for i64 (no vpmaxsq in AVX2)

<h2>fp_scan_add_i64 / fp_scan_add_f64</h2>

<pre><code>void fp_scan_add_i64(const int64_t<em> in, int64_t</em> out, size_t n);
void fp_scan_add_f64(const double<em> in, double</em> out, size_t n);
</code></pre>

FP: out = scanl1 (+) in  (inclusive prefix sum)
C:  acc = 0; for(i) { acc += in[i]; out[i] = acc; }
Example: [1, 2, 3, 4] -> [1, 3, 6, 10]
Win: Scalar with 4-way loop unrolling

<h2>fp_pred_all_eq_const_i64</h2>

<pre><code>bool fp_pred_all_eq_const_i64(const int64_t* arr, size_t n, int64_t value);
</code></pre>

FP: all (== value) arr
C:  for(i) if (arr[i] != value) return false; return true;
Returns true if ALL elements equal the constant value

<h2>fp_pred_any_gt_const_i64</h2>

<pre><code>bool fp_pred_any_gt_const_i64(const int64_t* arr, size_t n, int64_t value);
</code></pre>

FP: any (> value) arr
C:  for(i) if (arr[i] > value) return true; return false;
Returns true if ANY element is greater than the constant value

<h2>fp_pred_all_gt_zip_i64</h2>

<pre><code>bool fp_pred_all_gt_zip_i64(const int64_t<em> a, const int64_t</em> b, size_t n);
</code></pre>

FP: all (uncurry (>)) (zip a b)
C:  for(i) if (a[i] <= b[i]) return false; return true;
Returns true if ALL corresponding elements satisfy a[i] > b[i]

<h2>fp_filter_gt_i64_simple</h2>

<pre><code>size_t fp_filter_gt_i64_simple(const int64_t<em> input, int64_t</em> output, size_t n, int64_t threshold);
</code></pre>

FP: filter (> threshold) list
C:  result = []; for(i) if (arr[i] > threshold) result.append(arr[i]);
Returns: number of elements written to output

This is the CRITICAL test for "List FP" fitness!

<h2>fp_partition_gt_i64</h2>

<pre><code>void fp_partition_gt_i64(const int64_t<em> input, int64_t</em> output_pass, int64_t<em> output_fail, size_t n, int64_t threshold, size_t</em> out_pass_count, size_t* out_fail_count);
</code></pre>

FP: partition (> threshold) list ‚Üí (pass, fail)
C:  pass = []; fail = []; for(i) { if (arr[i] > thresh) pass.append(arr[i]); else fail.append(arr[i]); }

Splits input into two outputs based on predicate.

<h2>fp_take_while_gt_i64</h2>

<pre><code>size_t fp_take_while_gt_i64(const int64_t<em> input, int64_t</em> output, size_t n, int64_t threshold);
</code></pre>

FP: takeWhile (> threshold) list
C:  result = []; for(i) { if (arr[i] > threshold) result.append(arr[i]); else break; }

Takes elements while predicate is true, stops at first failure (early exit).

<h2>fp_drop_while_gt_i64</h2>

<pre><code>size_t fp_drop_while_gt_i64(const int64_t<em> input, int64_t</em> output, size_t n, int64_t threshold);
</code></pre>

FP: dropWhile (> threshold) list
C:  skip = true; for(i) { if (skip && arr[i] > threshold) continue; skip = false; result.append(arr[i]); }

Drops elements while predicate is true, returns rest (early exit).

<h2>fp_take_n_i64</h2>

<pre><code>size_t fp_take_n_i64(const int64_t<em> input, int64_t</em> output, size_t array_len, size_t take_count);
</code></pre>

FP: take n list
C:  for(i = 0; i < min(n, len); i++) output[i] = input[i];
Haskell: take 3 [1,2,3,4,5] ‚Üí [1,2,3]
Returns: number of elements taken

<h2>fp_drop_n_i64</h2>

<pre><code>size_t fp_drop_n_i64(const int64_t<em> input, int64_t</em> output, size_t array_len, size_t drop_count);
</code></pre>

FP: drop n list
C:  for(i = n; i < len; i++) output[i-n] = input[i];
Haskell: drop 2 [1,2,3,4,5] ‚Üí [3,4,5]
Returns: number of elements in output

<h2>fp_slice_i64</h2>

<pre><code>size_t fp_slice_i64(const int64_t<em> input, int64_t</em> output, size_t array_len, size_t start, size_t end);
</code></pre>

FP: take (end - start) . drop start
C:  for(i = start; i < end; i++) output[i-start] = input[i];
Haskell: slice 2 5 [0,1,2,3,4,5,6] ‚Üí [2,3,4]
Returns: number of elements in output

<h2>fp_reduce_product_i64 / fp_reduce_product_f64</h2>

<pre><code>int64_t fp_reduce_product_i64(const int64_t* input, size_t n);
double fp_reduce_product_f64(const double* input, size_t n);
</code></pre>

FP: product list
C:  result = 1; for(i) result *= arr[i];
Haskell: product [1,2,3,4] ‚Üí 24
Returns: product of all elements (1 for empty array)

<h2>fp_find_index_i64</h2>

<pre><code>int64_t fp_find_index_i64(const int64_t* input, size_t n, int64_t target);
</code></pre>

FP: findIndex (== target) list
C:  for(i) if (arr[i] == target) return i; return -1;
Haskell: findIndex (== 7) [1,3,7,2] ‚Üí Just 2
Returns: index of first match, or -1 if not found

<h2>fp_contains_i64</h2>

<pre><code>bool fp_contains_i64(const int64_t* input, size_t n, int64_t target);
</code></pre>

FP: elem target list
C:  for(i) if (arr[i] == target) return true; return false;
Haskell: elem 7 [1,3,7,2] ‚Üí True
Returns: 1 if found, 0 if not found

<h2>fp_reverse_i64</h2>

<pre><code>void fp_reverse_i64(const int64_t<em> input, int64_t</em> output, size_t n);
</code></pre>

FP: reverse list
C:  for(i) output[i] = input[n-1-i];
Haskell: reverse [1,2,3,4] ‚Üí [4,3,2,1]

<h2>fp_concat_i64</h2>

<pre><code>size_t fp_concat_i64(const int64_t<em> input_a, const int64_t</em> input_b, int64_t* output, size_t len_a, size_t len_b);
</code></pre>

FP: list1 ++ list2
C:  memcpy(output, a, na<em>8); memcpy(output+na, b, nb</em>8);
Haskell: [1,2,3] ++ [4,5,6] ‚Üí [1,2,3,4,5,6]
Returns: total length (len_a + len_b)

<h2>fp_replicate_i64</h2>

<pre><code>void fp_replicate_i64(int64_t* output, size_t n, int64_t value);
</code></pre>

FP: replicate n value
C:  for(i = 0; i < n; i++) output[i] = value;
Haskell: replicate 5 7 ‚Üí [7,7,7,7,7]

<h2>fp_sort_i64 / fp_sort_f64</h2>

<pre><code>void fp_sort_i64(int64_t* array, size_t n);
void fp_sort_f64(double* array, size_t n);
</code></pre>

FP: sort list
C:  qsort(array, n, sizeof(int64_t), cmp);
Haskell: sort [3,1,4,1,5,9] ‚Üí [1,1,3,4,5,9]

Implementation: Quicksort with median-of-3 pivot + insertion sort for small arrays
Note: Sorts in-place (modifies input array)

<h2>fp_unique_i64</h2>

<pre><code>size_t fp_unique_i64(const int64_t<em> input, int64_t</em> output, size_t n);
</code></pre>

FP: nub list  (remove consecutive duplicates)
C:  unique_copy(sorted_array, output);
Haskell: nub [1,2,2,3,3,3,4] ‚Üí [1,2,3,4]

Note: Input should be sorted for correctness
Returns: number of unique elements

<h2>fp_union_i64</h2>

<pre><code>size_t fp_union_i64(const int64_t<em> array_a, const int64_t</em> array_b, int64_t* output, size_t len_a, size_t len_b);
</code></pre>

FP: union list1 list2
C:  set_union(sorted_a, sorted_b, output);
Haskell: union [1,2,3] [2,3,4] ‚Üí [1,2,3,4]

Note: Both inputs should be sorted
Returns: number of elements in union

<h2>fp_intersect_i64</h2>

<pre><code>size_t fp_intersect_i64(const int64_t<em> array_a, const int64_t</em> array_b, int64_t* output, size_t len_a, size_t len_b);
</code></pre>

FP: intersect list1 list2
C:  set_intersection(sorted_a, sorted_b, output);
Haskell: intersect [1,2,3] [2,3,4] ‚Üí [2,3]

Note: Both inputs should be sorted
Returns: number of elements in intersection

<h2>fp_group_i64</h2>

<pre><code>size_t fp_group_i64(const int64_t<em> input, int64_t</em> groups_out, int64_t* counts_out, size_t n);
</code></pre>

FP: group list  (group consecutive equal elements)
Haskell: group [1,1,2,2,2,3] ‚Üí [[1,1],[2,2,2],[3]]

Due to C constraints, returns parallel arrays:
<ul><li>groups_out: representative value for each group</li>
<li>counts_out: size of each group</li></ul>

Returns: number of groups

<h2>fp_run_length_encode_i64</h2>

<pre><code>size_t fp_run_length_encode_i64(const int64_t<em> input, int64_t</em> output, size_t n);
</code></pre>

FP: Run-length encoding
Alternative: returns interleaved [val1, count1, val2, count2, ...]

More memory-efficient than separate arrays
Returns: number of output elements (groups * 2)

<h2>fp_iterate_add_i64</h2>

<pre><code>void fp_iterate_add_i64(int64_t* output, size_t n, int64_t start, int64_t step);
</code></pre>

FP: iterate (+step) start
Haskell: take n $ iterate (+step) start ‚Üí [start, start+step, start+2*step, ...]

Generates arithmetic sequence

<h2>fp_iterate_mul_i64</h2>

<pre><code>void fp_iterate_mul_i64(int64_t* output, size_t n, int64_t start, int64_t factor);
</code></pre>

FP: iterate (*factor) start
Haskell: take n $ iterate (<em>factor) start ‚Üí [start, start</em>factor, start*factor^2, ...]

Generates geometric sequence

<h2>fp_range_i64</h2>

<pre><code>size_t fp_range_i64(int64_t* output, int64_t start, int64_t end);
</code></pre>

FP: [start..end-1]
Haskell: [1..10] ‚Üí [1,2,3,4,5,6,7,8,9,10]

Generates range of integers
Returns: number of elements (max(0, end - start))

<h2>fp_reduce_and_bool</h2>

<pre><code>bool fp_reduce_and_bool(const int64_t* input, size_t n);
</code></pre>

FP: and list
Haskell: and [True, True, False] ‚Üí False

Returns: 1 if all elements are non-zero, 0 if any zero
Note: Treats int64_t as bool (0=false, non-zero=true)

<h2>fp_reduce_or_bool</h2>

<pre><code>bool fp_reduce_or_bool(const int64_t* input, size_t n);
</code></pre>

FP: or list
Haskell: or [False, False, True] ‚Üí True

Returns: 1 if any element is non-zero, 0 if all zero

<h2>fp_zip_with_index_i64</h2>

<pre><code>size_t fp_zip_with_index_i64(const int64_t<em> input, int64_t</em> output, size_t n);
</code></pre>

FP: zip [0..] list
Haskell: zip [0..] list ‚Üí [(0,x), (1,y), (2,z), ...]

Returns interleaved: [0, x, 1, y, 2, z, ...]
Returns: output length (n * 2)

<h2>fp_replicate_f64</h2>

<pre><code>void fp_replicate_f64(double* output, size_t n, double value);
</code></pre>

FP: replicate n value  (floating-point version)
Haskell: replicate 5 3.14 ‚Üí [3.14, 3.14, 3.14, 3.14, 3.14]

<h2>fp_count_i64</h2>

<pre><code>size_t fp_count_i64(const int64_t* input, size_t n, int64_t target);
</code></pre>

FP: length . filter (== x)
Haskell: count (== 5) [1,5,2,5,3] ‚Üí 2

Count occurrences of specific value

<h2>typedef struct { double mean;       // First moment (average) double variance;   // Second central moment double std_dev;    // Square root of variance double skewness;   // Third standardized moment (asymmetry) double kurtosis;   // Fourth standardized moment (tail heaviness) } DescriptiveStats;</h2>

<pre><code>typedef struct { double mean;       // First moment (average) double variance;   // Second central moment double std_dev;    // Square root of variance double skewness;   // Third standardized moment (asymmetry) double kurtosis;   // Fourth standardized moment (tail heaviness) } DescriptiveStats;
</code></pre>

Descriptive Statistics Structure
Contains: mean, variance, std_dev, skewness, kurtosis

<h2>fp_descriptive_stats_f64</h2>

<pre><code>void fp_descriptive_stats_f64(const double<em> data, size_t n, DescriptiveStats</em> stats);
</code></pre>

Calculate descriptive statistics in single pass

FP: Uses fused fold to compute all moments simultaneously
Haskell-style: foldl (\acc x -> updateMoments acc x) initialAcc data

@param data Input array of doubles
@param n Number of elements
@param stats Output structure with all statistics

Complexity: O(n) time, O(1) space
Performance: 1.5-2.0x vs naive C (single pass, fused operations)

<h2>fp_moments_f64</h2>

<pre><code>void fp_moments_f64(const double<em> data, size_t n, double</em> moments);
</code></pre>

Calculate raw statistical moments (internal function)

@param data Input array
@param n Number of elements
@param moments Output: [sum, sum_sq, sum_cube, sum_quad]

<h2>Quartiles</h2>

<pre><code>typedef struct { double q1;       // 25th percentile double median;   // 50th percentile (Q2) double q3;       // 75th percentile double iqr;      // Interquartile range (Q3 - Q1) } Quartiles;
</code></pre>

Quartiles structure
Contains Q1, median (Q2), Q3, and IQR

<h2>fp_percentile_f64</h2>

<pre><code>double fp_percentile_f64(const double* sorted_data, size_t n, double p);
</code></pre>

Calculate a single percentile from sorted data

IMPORTANT: Data must be sorted in ascending order!

@param sorted_data Input array (MUST BE SORTED)
@param n Number of elements
@param p Percentile (0.0 to 1.0, e.g., 0.5 for median, 0.95 for 95th percentile)
@return Percentile value using linear interpolation

Complexity: O(1) time (assumes data is already sorted)
Performance: 1.0x vs C (simple indexing + interpolation)

<h2>fp_percentiles_f64</h2>

<pre><code>void fp_percentiles_f64(const double<em> sorted_data, size_t n, const double</em> p_values, size_t n_percentiles, double* results);
</code></pre>

Calculate multiple percentiles at once (batch operation)

More efficient than calling fp_percentile_f64 repeatedly
IMPORTANT: Data must be sorted in ascending order!

@param sorted_data Input array (MUST BE SORTED)
@param n Number of elements
@param p_values Array of percentiles to calculate (each 0.0 to 1.0)
@param n_percentiles Number of percentiles to calculate
@param results Output array (must have space for n_percentiles values)

Complexity: O(k) where k = n_percentiles
Performance: 1.0x vs C (cache-friendly batch processing)

<h2>fp_quartiles_f64 / Quartiles</h2>

<pre><code>void fp_quartiles_f64(const double<em> sorted_data, size_t n, Quartiles</em> quartiles);
</code></pre>

Calculate quartiles (Q1, median, Q3) and IQR in one call

IMPORTANT: Data must be sorted in ascending order!
Commonly used for box plots and outlier detection

@param sorted_data Input array (MUST BE SORTED)
@param n Number of elements
@param quartiles Output structure

Complexity: O(1) time (assumes data is already sorted)
Performance: 1.0x vs C

<h2>fp_covariance_f64</h2>

<pre><code>double fp_covariance_f64(const double<em> x, const double</em> y, size_t n);
</code></pre>

Calculate covariance between two arrays

Covariance measures how two variables change together
Cov(X,Y) = E[(X - E[X])(Y - E[Y])] = E[XY] - E[X]E[Y]

Uses single-pass fused algorithm for efficiency

@param x First array
@param y Second array
@param n Number of elements (must be same for both arrays)
@return Covariance value

Complexity: O(n) time, O(1) space
Performance: 2.0-2.5x vs naive C (fused operations, single pass)

<h2>fp_correlation_f64</h2>

<pre><code>double fp_correlation_f64(const double<em> x, const double</em> y, size_t n);
</code></pre>

Calculate Pearson correlation coefficient

Correlation measures linear relationship strength between two variables
Returns value in range [-1.0, 1.0]:
  -1.0 = perfect negative correlation
   0.0 = no linear correlation
  +1.0 = perfect positive correlation

Formula: r = Cov(X,Y) / (StdDev(X) * StdDev(Y))
Uses single-pass fused algorithm for maximum efficiency

@param x First array
@param y Second array
@param n Number of elements
@return Correlation coefficient (-1.0 to 1.0, or NaN if undefined)

Complexity: O(n) time, O(1) space
Performance: 2.0-2.5x vs naive C (single pass, fused operations)

<h2>LinearRegression</h2>

<pre><code>typedef struct { double slope;           /<strong>< Slope (m) of the regression line <em>/ double intercept;       /</strong>< Y-intercept (b) of the regression line </em>/ double r_squared;       /<strong>< Coefficient of determination (0.0 to 1.0) <em>/ double std_error;       /</strong>< Standard error of estimate </em>/ } LinearRegression;
</code></pre>

Linear regression model: y = mx + b
Contains fitted coefficients and quality metrics

<h2>fp_linear_regression_f64 / LinearRegression</h2>

<pre><code>void fp_linear_regression_f64(const double<em> x, const double</em> y, size_t n, LinearRegression* result);
</code></pre>

Compute linear regression: y = mx + b

Fits a line to the data using least squares method
Computes slope, intercept, R¬≤, and standard error

Formulas:
  slope = Cov(X,Y) / Var(X)
  intercept = mean(Y) - slope * mean(X)
  R¬≤ = (correlation)¬≤ (proportion of variance explained)
  std_error = sqrt(Œ£(y_i - y_pred_i)¬≤ / (n-2))

Uses two-pass algorithm:
  Pass 1: Compute statistics for slope/intercept/R¬≤ (single-pass SIMD)
  Pass 2: Compute residuals for standard error

@param x Independent variable (predictor)
@param y Dependent variable (response)
@param n Number of data points (must be >= 2)
@param result Output struct for regression model

Edge cases:
  - n < 2: All fields set to NaN
  - n == 2: Perfect fit (R¬≤=1.0, std_error=0.0)
  - Zero variance in x: All fields set to NaN

Complexity: O(n) time, O(1) space
Performance: 2.0-2.5x vs naive C (SIMD first pass, scalar second pass)

<h2>fp_predict_f64 / LinearRegression</h2>

<pre><code>double fp_predict_f64(double x_value, const LinearRegression* model);
</code></pre>

Make prediction using linear regression model

Given x value, computes y = slope * x + intercept

@param x_value Input value for prediction
@param model Previously fitted regression model
@return Predicted y value

Complexity: O(1) time, O(1) space
Performance: Same as C (simple arithmetic, no optimization needed)

<h2>fp_detect_outliers_zscore_f64</h2>

<pre><code>size_t fp_detect_outliers_zscore_f64(const double<em> data, size_t n, double threshold, uint8_t</em> is_outlier);
</code></pre>

Detect outliers using Z-score method

The Z-score measures how many standard deviations a point is from the mean:
  z = (x - mean) / stddev

A point is marked as an outlier if |z| > threshold (typically 3.0)

Uses two-pass algorithm:
  Pass 1: Compute mean and standard deviation (SIMD)
  Pass 2: Calculate Z-scores and mark outliers (scalar)

@param data Input array (unsorted)
@param n Number of elements
@param threshold Z-score threshold (typically 2.0-3.0)
@param is_outlier Output array (1=outlier, 0=normal), must be size n
@return Number of outliers detected

Edge cases:
  - n < 2: No outliers detected
  - All values identical (stddev=0): No outliers

Complexity: O(n) time, O(1) space (excluding output)
Performance: 2.0-2.5x vs naive C (SIMD first pass)

<h2>fp_detect_outliers_iqr_f64</h2>

<pre><code>size_t fp_detect_outliers_iqr_f64(const double<em> sorted_data, size_t n, double k_factor, uint8_t</em> is_outlier);
</code></pre>

Detect outliers using IQR (Interquartile Range) method

The IQR method is robust to extreme values:
  IQR = Q3 - Q1
  lower_bound = Q1 - k * IQR
  upper_bound = Q3 + k * IQR

A point is an outlier if x < lower_bound or x > upper_bound
where k is typically 1.5 (outlier) or 3.0 (extreme outlier)

IMPORTANT: This function requires SORTED data!

@param sorted_data Input array (MUST be sorted!)
@param n Number of elements
@param k_factor IQR multiplier (typically 1.5)
@param is_outlier Output array (1=outlier, 0=normal), must be size n
@return Number of outliers detected

Edge cases:
  - n < 4: No outliers detected (insufficient data for quartiles)

Complexity: O(n) time, O(1) space (excluding output)
Performance: 1.5-2.0x vs naive C (uses percentile calculation)

        </main>
    </div>
</body>
</html>
