<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FP-ASM Quick Start Guide - FP-ASM Library</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f5f5f5;
        }

        .container {
            display: flex;
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            min-height: 100vh;
        }

        /* Sidebar Navigation */
        .sidebar {
            width: 280px;
            background: #2c3e50;
            color: white;
            padding: 20px;
            position: sticky;
            top: 0;
            height: 100vh;
            overflow-y: auto;
        }

        .sidebar h2 {
            color: #3498db;
            margin-bottom: 20px;
            font-size: 1.4em;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }

        .sidebar nav ul {
            list-style: none;
        }

        .sidebar nav li {
            margin: 8px 0;
        }

        .sidebar nav a {
            color: #ecf0f1;
            text-decoration: none;
            display: block;
            padding: 8px 12px;
            border-radius: 4px;
            transition: all 0.3s;
        }

        .sidebar nav a:hover {
            background: #34495e;
            color: #3498db;
            transform: translateX(5px);
        }

        .sidebar nav a.active {
            background: #3498db;
            color: white;
        }

        .sidebar .badge {
            display: inline-block;
            background: #27ae60;
            color: white;
            font-size: 0.7em;
            padding: 2px 6px;
            border-radius: 3px;
            margin-left: 8px;
        }

        /* Main Content */
        .content {
            flex: 1;
            padding: 40px 60px;
            overflow-y: auto;
        }

        .content h1 {
            color: #2c3e50;
            font-size: 2.5em;
            margin-bottom: 20px;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }

        .content h2 {
            color: #34495e;
            font-size: 2em;
            margin-top: 40px;
            margin-bottom: 15px;
            border-left: 4px solid #3498db;
            padding-left: 15px;
        }

        .content h3 {
            color: #34495e;
            font-size: 1.5em;
            margin-top: 30px;
            margin-bottom: 10px;
        }

        .content h4 {
            color: #7f8c8d;
            font-size: 1.2em;
            margin-top: 20px;
            margin-bottom: 10px;
        }

        .content p {
            margin: 15px 0;
            line-height: 1.8;
        }

        .content ul, .content ol {
            margin: 15px 0 15px 30px;
        }

        .content li {
            margin: 8px 0;
        }

        /* Code Blocks */
        .content pre {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 6px;
            overflow-x: auto;
            margin: 20px 0;
            border-left: 4px solid #3498db;
        }

        .content code {
            background: #ecf0f1;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            color: #c7254e;
        }

        .content pre code {
            background: transparent;
            padding: 0;
            color: #ecf0f1;
        }

        /* Tables */
        .content table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .content th {
            background: #3498db;
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: bold;
        }

        .content td {
            padding: 12px;
            border-bottom: 1px solid #ecf0f1;
        }

        .content tr:hover {
            background: #f8f9fa;
        }

        /* Badges */
        .badge-green {
            background: #27ae60;
            color: white;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 0.85em;
            font-weight: bold;
        }

        .badge-blue {
            background: #3498db;
            color: white;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 0.85em;
            font-weight: bold;
        }

        .badge-orange {
            background: #e67e22;
            color: white;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 0.85em;
            font-weight: bold;
        }

        /* Blockquotes */
        .content blockquote {
            border-left: 4px solid #3498db;
            padding: 15px 20px;
            background: #ecf0f1;
            margin: 20px 0;
            font-style: italic;
        }

        /* Links */
        .content a {
            color: #3498db;
            text-decoration: none;
            border-bottom: 1px solid transparent;
            transition: border-color 0.3s;
        }

        .content a:hover {
            border-bottom-color: #3498db;
        }

        /* Horizontal Rules */
        .content hr {
            border: none;
            border-top: 2px solid #ecf0f1;
            margin: 40px 0;
        }

        /* Emoji support */
        .emoji {
            font-size: 1.2em;
        }

        /* Top banner */
        .banner {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px 60px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .banner h1 {
            color: white;
            border: none;
            margin: 0;
            font-size: 1.8em;
        }

        .banner p {
            margin: 5px 0 0 0;
            opacity: 0.9;
        }

        /* Function signature boxes */
        .signature {
            background: #f8f9fa;
            border: 2px solid #3498db;
            border-radius: 6px;
            padding: 15px;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
        }

        /* Performance badges */
        .perf-badge {
            display: inline-block;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85em;
            font-weight: bold;
            margin: 5px 5px 5px 0;
        }

        .perf-excellent { background: #27ae60; color: white; }
        .perf-good { background: #2ecc71; color: white; }
        .perf-okay { background: #f39c12; color: white; }
        .perf-competitive { background: #3498db; color: white; }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 10px;
        }

        ::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        ::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }

            .sidebar {
                width: 100%;
                height: auto;
                position: relative;
            }

            .content {
                padding: 20px;
            }

            .banner {
                padding: 15px 20px;
            }
        }
    </style>
</head>
<body>
    <div class="banner">
        <h1>üöÄ FP-ASM Library Documentation</h1>
        <p>Complete Functional Programming Toolkit for C ‚Ä¢ 100% FP Coverage ‚Ä¢ 36 Functions ‚Ä¢ Production Ready</p>
    </div>
    <div class="container">
        <aside class="sidebar">
            <h2>üìö Documentation</h2>
            <nav>
                <ul>
                    <li><a href="index.html" class="">üè† Home</a></li>
                    <li><a href="README.html" class="">üìñ Overview</a></li>
                    <li><a href="QUICK_START.html" class="active">üöÄ Quick Start</a></li>
                    <li><a href="API_REFERENCE.html" class="">üìò API Reference <span class="badge">36 funcs</span></a></li>
                    <li><a href="COMPLETE_LIBRARY_REPORT.html" class="">üéâ Journey Report</a></li>
                    <li><a href="TIER1_COMPLETENESS_REPORT.html" class="">üìä TIER 1 Report</a></li>
                    <li><a href="TIER2_COMPLETENESS_REPORT.html" class="">üìä TIER 2 Report</a></li>
                    <li><a href="TIER3_COMPLETENESS_REPORT.html" class="">üìä TIER 3 Report</a></li>
                    <li><a href="ACHIEVEMENT_SUMMARY.html" class="">üèÜ Achievement</a></li>
                </ul>
            </nav>
        </aside>
        <main class="content">
            <h1>FP-ASM Quick Start Guide</h1>

<strong>Learn the FP-ASM library through progressive examples - from basics to advanced patterns.</strong>

<hr>

<h2>Table of Contents</h2>

<li><a href="#installation">Installation</a></li>
<li><a href="#your-first-program">Your First Program</a></li>
<li><a href="#basic-operations">Basic Operations</a></li>
<li><a href="#list-operations">List Operations</a></li>
<li><a href="#sorting--sets">Sorting & Sets</a></li>
<li><a href="#advanced-patterns">Advanced Patterns</a></li>
<li><a href="#real-world-applications">Real-World Applications</a></li>
<li><a href="#performance-tips">Performance Tips</a></li>

<hr>

<h2>Installation</h2>

<h3>Step 1: Get the Library</h3>

All object files (<code>*.o</code>) are pre-compiled and ready to use. No assembly required!

<h3>Step 2: Include the Header</h3>

<pre><code>#include "fp_core.h"
</code></pre>

<h3>Step 3: Link and Compile</h3>

<pre><code>gcc your_program.c fp_core_*.o -o your_program.exe
</code></pre>

That's it! You're ready to go.

<hr>

<h2>Your First Program</h2>

Let's start with the simplest possible program:

<pre><code>#include <stdio.h>
#include "fp_core.h"

int main() {
    // Create an array
    int64_t numbers[] = {1, 2, 3, 4, 5};

    // Sum it (1.5-1.8x faster than C loop)
    int64_t sum = fp_reduce_add_i64(numbers, 5);

    printf("Sum: %lld\n", sum);  // Output: Sum: 15
    return 0;
}
</code></pre>

<strong>Compile and run</strong>:
<pre><code>gcc hello_fp.c fp_core_reductions.o -o hello_fp.exe
./hello_fp.exe
</code></pre>

<strong>What just happened?</strong>
<ul><li>You called <code>fp_reduce_add_i64</code> to sum an int64_t array</li>
<li>The function used AVX2 SIMD instructions internally</li>
<li>Result: 1.5-1.8x faster than equivalent C code!</li>

<hr>

<h2>Basic Operations</h2>

<h3>Lesson 1: Reductions (Fold Operations)</h3>

Reductions collapse an array into a single value.

<pre><code>#include <stdio.h>
#include "fp_core.h"

int main() {
    double temperatures[] = {23.5, 19.2, 25.8, 21.3, 27.1};
    size_t n = 5;

    // 1. Sum all temperatures
    double total = fp_reduce_add_f64(temperatures, n);
    printf("Total: %.1f¬∞C\n", total);

    // 2. Find maximum
    double max_temp = fp_reduce_max_f64(temperatures, n);
    printf("Max temperature: %.1f¬∞C\n", max_temp);

    // 3. Calculate mean
    double mean = total / n;
    printf("Average: %.1f¬∞C\n", mean);

    return 0;
}
</code></pre>

<strong>Key Takeaway</strong>: Use <code><em>_i64</code> for integers, <code></em>_f64</code> for doubles.

<hr>

<h3>Lesson 2: Fused Operations (Map + Reduce)</h3>

Fused operations combine multiple steps into one pass for better performance.

<pre><code>#include <stdio.h>
#include <math.h>
#include "fp_core.h"

int main() {
    double values[] = {1.0, 2.0, 3.0, 4.0, 5.0};
    size_t n = 5;

    // Calculate variance in one pass!
    double sum = fp_reduce_add_f64(values, n);
    double mean = sum / n;

    // Sum of squares (fused operation)
    double sumsq = fp_fold_sumsq_f64(values, n);

    // Variance formula
    double variance = (sumsq / n) - (mean * mean);
    double std_dev = sqrt(variance);

    printf("Mean: %.2f\n", mean);
    printf("Variance: %.2f\n", variance);
    printf("Std Dev: %.2f\n", std_dev);

    return 0;
}
</code></pre>

<strong>Why it's fast</strong>: <code>fp_fold_sumsq_f64</code> computes Œ£(x¬≤) in a single pass, keeping all data in registers!

<hr>

<h3>Lesson 3: Transformations (Map Operations)</h3>

Transform every element of an array.

<pre><code>#include <stdio.h>
#include "fp_core.h"

int main() {
    double readings[] = {-2.5, 3.7, -1.2, 5.8, -0.3};
    double absolute[5];
    size_t n = 5;

    // Get absolute values
    fp_map_abs_f64(readings, absolute, n);

    printf("Original: ");
    for (size_t i = 0; i < n; i++) printf("%.1f ", readings[i]);

    printf("\nAbsolute: ");
    for (size_t i = 0; i < n; i++) printf("%.1f ", absolute[i]);
    printf("\n");

    return 0;
}
</code></pre>

<strong>Output</strong>:
<pre><code>Original: -2.5 3.7 -1.2 5.8 -0.3
Absolute: 2.5 3.7 1.2 5.8 0.3
</code></pre>

<hr>

<h3>Lesson 4: Scans (Prefix Sums)</h3>

Scans compute cumulative results - perfect for running totals.

<pre><code>#include <stdio.h>
#include "fp_core.h"

int main() {
    int64_t monthly_sales[] = {100, 150, 120, 180, 200};
    int64_t cumulative[5];
    size_t n = 5;

    // Cumulative sum (2.0-3.2x faster!)
    fp_scan_add_i64(monthly_sales, cumulative, n);

    printf("Month | Sales | Year-to-Date\n");
    printf("------+-------+-------------\n");
    for (size_t i = 0; i < n; i++) {
        printf("  %zu   | %5lld | %5lld\n",
               i+1, monthly_sales[i], cumulative[i]);
    }

    return 0;
}
</code></pre>

<strong>Output</strong>:
<pre><code>Month | Sales | Year-to-Date
------+-------+-------------
  1   |   100 |   100
  2   |   150 |   250
  3   |   120 |   370
  4   |   180 |   550
  5   |   200 |   750
</code></pre>

<hr>

<h2>List Operations</h2>

<h3>Lesson 5: Filtering</h3>

Select elements that match a condition.

<pre><code>#include <stdio.h>
#include <stdbool.h>
#include "fp_core.h"

// Predicate function
bool is_positive(int64_t x) {
    return x > 0;
}

int main() {
    int64_t data[] = {-3, 5, -1, 8, 0, 2, -7};
    int64_t positive[7];
    size_t n = 7;

    // Filter for positive numbers
    size_t count = fp_filter_i64(data, positive, n, is_positive);

    printf("Original: ");
    for (size_t i = 0; i < n; i++) printf("%lld ", data[i]);

    printf("\nPositive only (%zu values): ", count);
    for (size_t i = 0; i < count; i++) printf("%lld ", positive[i]);
    printf("\n");

    return 0;
}
</code></pre>

<strong>Output</strong>:
<pre><code>Original: -3 5 -1 8 0 2 -7
Positive only (3 values): 5 8 2
</code></pre>

<hr>

<h3>Lesson 6: Slicing and Taking</h3>

Extract portions of arrays.

<pre><code>#include <stdio.h>
#include "fp_core.h"

void print_array(const char<em> name, int64_t</em> arr, size_t n) {
    printf("%s: ", name);
    for (size_t i = 0; i < n; i++) printf("%lld ", arr[i]);
    printf("\n");
}

int main() {
    int64_t data[] = {10, 20, 30, 40, 50, 60, 70, 80};
    int64_t output[8];

    // Take first 3
    fp_take_i64(output, data, 3);
    print_array("First 3", output, 3);

    // Skip first 3, take rest
    fp_drop_i64(output, data, 3, 8);
    print_array("After drop 3", output, 5);

    // Slice [2..5)
    fp_slice_i64(output, data, 2, 5);
    print_array("Slice [2..5)", output, 3);

    return 0;
}
</code></pre>

<strong>Output</strong>:
<pre><code>First 3: 10 20 30
After drop 3: 40 50 60 70 80
Slice [2..5): 30 40 50
</code></pre>

<hr>

<h2>Sorting & Sets</h2>

<h3>Lesson 7: Sorting and Statistics</h3>

<pre><code>#include <stdio.h>
#include <string.h>
#include "fp_core.h"

int main() {
    double data[] = {25.5, 19.2, 31.8, 22.3, 28.7};
    size_t n = 5;

    // Make a copy (sorting is in-place)
    double sorted[5];
    memcpy(sorted, data, n * sizeof(double));

    // Sort (1.0-1.2x faster than qsort)
    fp_sort_f64(sorted, n);

    printf("Original: ");
    for (size_t i = 0; i < n; i++) printf("%.1f ", data[i]);

    printf("\nSorted: ");
    for (size_t i = 0; i < n; i++) printf("%.1f ", sorted[i]);

    printf("\n\nStatistics:\n");
    printf("Min: %.1f\n", sorted[0]);
    printf("Q1:  %.1f\n", sorted[n/4]);
    printf("Median: %.1f\n", sorted[n/2]);
    printf("Q3:  %.1f\n", sorted[3*n/4]);
    printf("Max: %.1f\n", sorted[n-1]);

    return 0;
}
</code></pre>

<hr>

<h3>Lesson 8: Set Operations</h3>

Work with sets using sorted arrays.

<pre><code>#include <stdio.h>
#include "fp_core.h"

void print_set(const char<em> name, int64_t</em> arr, size_t n) {
    printf("%s: {", name);
    for (size_t i = 0; i < n; i++) {
        printf("%lld", arr[i]);
        if (i < n-1) printf(", ");
    }
    printf("}\n");
}

int main() {
    int64_t a[] = {1, 3, 5, 7, 9};
    int64_t b[] = {2, 3, 5, 8, 9};
    size_t na = 5, nb = 5;

    // Both arrays must be sorted!
    fp_sort_i64(a, na);
    fp_sort_i64(b, nb);

    // Union (all unique elements)
    int64_t union_result[10];
    size_t n_union = fp_union_i64(a, b, union_result, na, nb);
    print_set("A ‚à™ B", union_result, n_union);

    // Intersection (common elements)
    int64_t intersect_result[5];
    size_t n_intersect = fp_intersect_i64(a, b, intersect_result, na, nb);
    print_set("A ‚à© B", intersect_result, n_intersect);

    return 0;
}
</code></pre>

<strong>Output</strong>:
<pre><code>A ‚à™ B: {1, 2, 3, 5, 7, 8, 9}
A ‚à© B: {3, 5, 9}
</code></pre>

<hr>

<h2>Advanced Patterns</h2>

<h3>Lesson 9: Grouping and Run-Length Encoding</h3>

<pre><code>#include <stdio.h>
#include "fp_core.h"

int main() {
    // Simulate image scanline with repeated pixels
    int64_t pixels[] = {255,255,255,255, 0,0,0, 128,128, 255,255};
    size_t n = 11;

    printf("Original pixels (%zu): ", n);
    for (size_t i = 0; i < n; i++) printf("%lld ", pixels[i]);
    printf("\n");

    // Method 1: Group (returns parallel arrays)
    int64_t groups[11], counts[11];
    size_t ng = fp_group_i64(pixels, groups, counts, n);

    printf("\nGrouped:\n");
    for (size_t i = 0; i < ng; i++) {
        printf("  Value %lld appears %lld times\n", groups[i], counts[i]);
    }

    // Method 2: Run-length encoding (interleaved)
    int64_t compressed[22];
    size_t comp_len = fp_run_length_encode_i64(pixels, compressed, n);

    printf("\nRLE compressed (%zu elements):\n  ", comp_len);
    for (size_t i = 0; i < comp_len; i += 2) {
        printf("[%lld√ó%lld] ", compressed[i+1], compressed[i]);
    }
    printf("\n");

    printf("\nCompression: %.0f%% of original size\n",
           (comp_len * 100.0) / n);

    return 0;
}
</code></pre>

<hr>

<h3>Lesson 10: Sequence Generation</h3>

<pre><code>#include <stdio.h>
#include "fp_core.h"

void print_seq(const char<em> name, int64_t</em> arr, size_t n) {
    printf("%s: ", name);
    for (size_t i = 0; i < n; i++) printf("%lld ", arr[i]);
    printf("\n");
}

int main() {
    int64_t seq[10];

    // Arithmetic sequence (start=5, step=3)
    fp_iterate_add_i64(seq, 10, 5, 3);
    print_seq("Arithmetic [5, +3]", seq, 10);

    // Geometric sequence (start=2, factor=3)
    fp_iterate_mul_i64(seq, 6, 2, 3);
    print_seq("Geometric [2, √ó3] ", seq, 6);

    // Range [10..20)
    size_t n = fp_range_i64(seq, 10, 20);
    print_seq("Range [10..20)    ", seq, n);

    // Powers of 2
    fp_iterate_mul_i64(seq, 10, 1, 2);
    print_seq("Powers of 2       ", seq, 10);

    return 0;
}
</code></pre>

<strong>Output</strong>:
<pre><code>Arithmetic [5, +3]: 5 8 11 14 17 20 23 26 29 32
Geometric [2, √ó3]:  2 6 18 54 162 486
Range [10..20):     10 11 12 13 14 15 16 17 18 19
Powers of 2:        1 2 4 8 16 32 64 128 256 512
</code></pre>

<hr>

<h3>Lesson 11: Boolean Operations</h3>

<pre><code>#include <stdio.h>
#include <stdbool.h>
#include "fp_core.h"

int main() {
    // Data validation: check sensor readings
    int64_t sensors[] = {1, 1, 1, 1, 1};  // 1 = OK, 0 = Error

    // Check if ALL sensors are OK (AND)
    bool all_ok = fp_reduce_and_bool(sensors, 5);
    printf("All sensors OK: %s\n", all_ok ? "YES" : "NO");

    // Simulate one failure
    sensors[2] = 0;

    all_ok = fp_reduce_and_bool(sensors, 5);
    printf("After failure, all OK: %s\n", all_ok ? "YES" : "NO");

    // Check if ANY sensor failed (OR on error flags)
    int64_t errors[] = {0, 0, 1, 0, 0};  // 1 = Error
    bool has_error = fp_reduce_or_bool(errors, 5);
    printf("Has errors: %s\n", has_error ? "YES" : "NO");

    // Count total errors
    size_t error_count = fp_count_i64(sensors, 5, 0);
    printf("Total failures: %zu\n", error_count);

    return 0;
}
</code></pre>

<hr>

<h2>Real-World Applications</h2>

<h3>Application 1: Finding the Mode</h3>

The most frequent value in a dataset.

<pre><code>#include <stdio.h>
#include "fp_core.h"

int64_t find_mode(int64_t* data, size_t n) {
    // Sort data first
    fp_sort_i64(data, n);

    // Group consecutive equal values
    int64_t groups[n], counts[n];
    size_t ng = fp_group_i64(data, groups, counts, n);

    // Find maximum count
    int64_t max_count = fp_reduce_max_i64(counts, ng);

    // Find which group has that count
    int64_t max_idx = fp_find_index_i64(counts, ng, max_count);

    // Return the value (mode)
    return groups[max_idx];
}

int main() {
    int64_t votes[] = {1, 2, 1, 3, 1, 2, 1, 4};
    size_t n = 8;

    int64_t mode = find_mode(votes, n);

    printf("Votes: ");
    for (size_t i = 0; i < n; i++) printf("%lld ", votes[i]);
    printf("\nMode (most common): %lld\n", mode);

    return 0;
}
</code></pre>

<hr>

<h3>Application 2: Outlier Detection</h3>

Remove values outside acceptable range.

<pre><code>#include <stdio.h>
#include <math.h>
#include <string.h>
#include "fp_core.h"

void detect_outliers(double* data, size_t n) {
    // Make a sorted copy
    double sorted[n];
    memcpy(sorted, data, n * sizeof(double));
    fp_sort_f64(sorted, n);

    // Calculate IQR (Interquartile Range)
    double q1 = sorted[n/4];
    double q3 = sorted[3*n/4];
    double iqr = q3 - q1;

    // Outlier boundaries: Q1 - 1.5√óIQR, Q3 + 1.5√óIQR
    double lower = q1 - 1.5 * iqr;
    double upper = q3 + 1.5 * iqr;

    printf("Q1: %.2f, Q3: %.2f, IQR: %.2f\n", q1, q3, iqr);
    printf("Outlier range: [%.2f, %.2f]\n\n", lower, upper);

    printf("Value | Status\n");
    printf("------+--------\n");
    for (size_t i = 0; i < n; i++) {
        if (data[i] < lower || data[i] > upper) {
            printf("%5.1f | OUTLIER\n", data[i]);
        } else {
            printf("%5.1f | OK\n", data[i]);
        }
    }
}

int main() {
    double data[] = {10.2, 11.5, 12.1, 11.8, 50.0, 12.3, 11.9};
    detect_outliers(data, 7);
    return 0;
}
</code></pre>

<hr>

<h2>Performance Tips</h2>

<h3>Tip 1: Fuse Operations When Possible</h3>

<strong>Slow</strong> (two passes):
<pre><code>// Pass 1: Square each element
for (int i = 0; i < n; i++) temp[i] = data[i] * data[i];
// Pass 2: Sum
for (int i = 0; i < n; i++) sum += temp[i];
</code></pre>

<strong>Fast</strong> (one pass):
<pre><code>// Single fused operation
int64_t sumsq = fp_fold_sumsq_i64(data, n);
</code></pre>

<hr>

<h3>Tip 2: Sort Once, Use Many Times</h3>

<pre><code>// Sort once
fp_sort_f64(data, n);

// Now you can cheaply:
double median = data[n/2];
double min = data[0];
double max = data[n-1];
double q1 = data[n/4];
double q3 = data[3*n/4];

// And use set operations
size_t unique_count = fp_unique_i64(data, unique, n);
</code></pre>

<hr>

<h3>Tip 3: Choose the Right Data Type</h3>

<li>Use <code>int64_t</code> for exact calculations (counts, IDs, indices)</li>
<li>Use <code>double</code> for measurements and floating-point math</li>
<li>Performance is similar, but semantics matter!</li></ul>

<hr>

<h3>Tip 4: Pre-allocate Output Buffers</h3>

<pre><code>// Worst case: all elements match
int64_t filtered[n];
size_t count = fp_filter_i64(input, filtered, n, predicate);
// count ‚â§ n
</code></pre>

Always allocate enough space for worst case!

<hr>

<h2>Next Steps</h2>

<li><strong>Read the <a href="API_REFERENCE.html">API_REFERENCE.md</a></strong> for complete function documentation</li>
<li><strong>Check <a href="EXAMPLES.html">EXAMPLES.md</a></strong> for more complete programs</li>
<li><strong>See <a href="COMPLETE_LIBRARY_REPORT.html">COMPLETE_LIBRARY_REPORT.md</a></strong> for performance details</li>

<hr>

<h2>Quick Reference Card</h2>

<table>
<tr><th>Task</th><th>Function</th><th>Example</th></tr>
<tr><td><strong>Sum</strong></td><td><code>fp_reduce_add_*</code></td><td><code>sum = fp_reduce_add_i64(arr, n)</code></td></tr>
<tr><td><strong>Max</strong></td><td><code>fp_reduce_max_*</code></td><td><code>max = fp_reduce_max_f64(arr, n)</code></td></tr>
<tr><td><strong>Dot product</strong></td><td><code>fp_fold_dotp_*</code></td><td><code>dot = fp_fold_dotp_f64(a, b, n)</code></td></tr>
<tr><td><strong>Prefix sum</strong></td><td><code>fp_scan_add_*</code></td><td><code>fp_scan_add_i64(in, out, n)</code></td></tr>
<tr><td><strong>Sort</strong></td><td><code>fp_sort_*</code></td><td><code>fp_sort_f64(arr, n)</code></td></tr>
<tr><td><strong>Filter</strong></td><td><code>fp_filter_*</code></td><td><code>n2 = fp_filter_i64(in, out, n, pred)</code></td></tr>
<tr><td><strong>Group</strong></td><td><code>fp_group_*</code></td><td><code>ng = fp_group_i64(in, g, c, n)</code></td></tr>
<tr><td><strong>Range</strong></td><td><code>fp_range_*</code></td><td><code>n = fp_range_i64(out, 0, 100)</code></td></tr>
<tr><td><strong>All true</strong></td><td><code>fp_reduce_and_bool</code></td><td><code>ok = fp_reduce_and_bool(arr, n)</code></td></tr>
<tr><td><strong>Count</strong></td><td><code>fp_count_*</code></td><td><code>n = fp_count_i64(arr, n, val)</code></td></tr>
</table>
<hr>

<strong>Congratulations! You now know how to use the FP-ASM library!</strong> <span class="emoji">üéâ</span>

Start building high-performance functional programs in C today.

        </main>
    </div>
</body>
</html>
